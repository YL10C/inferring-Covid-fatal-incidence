# 推断 Covid 致死率

## 1. 数据准备与处理

### 读取并预处理死亡数据

- 读取死亡数据

	- 使用read.table函数读取数据文件engcov.txt

	- 使用数据的前150天（前150行），提取以下列

		- julian：一年中的第几天（1表示2020年1月1日）

		- nhs：当天在英格兰医院的COVID-19死亡人数

- 生成死亡日期向量

	- 使用rep函数，根据每天的死亡人数，生成一个长度为n = 29422的死亡日期向量

	- 这个向量表示每个死亡病例发生的具体日期

### 计算感染到死亡的持续时间分布

- 使用给定的对数正态分布参数

	- meanlog = 3.152

	- sdlog = 0.451

- 生成持续时间为1到80天的整数天数的概率分布

	- 计算每个天数对应的概率密度值

	- 将这些概率归一化，使总和为1

- 生成一个长度为80的概率向量，用于在后续步骤中抽样感染到死亡的持续时间

## 2. 初始感染时间的估计

### 为每个死亡病例生成初始感染时间猜测

- 抽样感染到死亡的持续时间

	- 使用sample函数，从1到80天的持续时间中，根据计算的概率分布，为每个死亡病例抽样一个持续时间

- 计算初始感染时间

	- 对于每个死亡病例：
初始感染时间估计 = 死亡日期 - 感染到死亡的持续时间

	- 生成一个初始的感染时间向量 t0

## 3. 模拟与优化算法的实现

### 定义适合度函数（修改的Pearson统计量）

- 模拟死亡时间

	- 在每次迭代中，保持感染时间t0和感染到死亡的持续时间不变，计算模拟的死亡日期向量

	- 使用tabulate函数，将模拟的死亡日期向量转换为每日的死亡人数

- 使用修改的Pearson统计量P来衡量模拟的死亡时间分布与实际数据的差异

  怎么模拟死亡的时间？之前不是根据真实的死亡时间在模拟计算感染时间吗？
  
  这是一个函数，需要输入模拟的死亡时间。这个模拟死亡时间由上一步生成。
  
	-  

	- 实际的第 𝑖 天的死亡人数

	- 模拟的第 𝑖 天的死亡人数

	- 结果 p 代表实际死亡时间分布和模拟死亡时间分布之间的差异。

### 实现迭代算法，优化感染时间猜测

- 总体迭代次数： n.rep

- 在每次总体迭代中

	- 随机调整感染时间

		- 随机打乱t0的索引顺序，确保更新顺序是随机的

		- 对于t0中的每个元素

			- 随机选择一个调整步长，例如从{-4, -2, -1, 1, 2, 4}中抽样

			- 提议的新感染时间 = 当前感染时间 + 调整步长

			- 注意： 感染到死亡的持续时间保持不变

	- 计算新的模拟死亡时间和适合度

		- 使用更新后的感染时间 t0，计算新的模拟死亡日期和每日死亡人数

		- 计算新的适合度值 P_new

			- 计算 ΔP

			- 一共有两个日期受到影响：current，proposed
每个日期有两钟状态：调整前，调整后

			- 调整前

				-  

				-  

			- 调整后

				-  

				-  

			- 计算总的P值变化量：

	- 接受或拒绝提议的调整

		- 如果P_new小于当前的P，则接受调整，更新 t0 和 P

		- 否则，拒绝调整，保持 t0 和 P 不变

- 步长调整策略

	- 前50次迭代： 使用较大的步长集合，例如{-8, -4, -2, -1, 1, 2, 4, 8}

	- 接下来的25次迭代： 使用中等步长集合，例如{-4, -2, -1, 1, 2, 4}

	- 最后的25次迭代： 使用较小的步长集合，例如{-2, -1, 1, 2}

	- 存储结果

		- 在每次总体迭代结束后，记录当前的P值

		- 记录当前的每日新感染人数，存储在inft矩阵的对应列中

## 4. 函数deconv的编写

### 按照指定的函数签名和要求，编写核心函数

- deconv <- function(t, deaths, n.rep=100, bs=FALSE, t0=NULL) {
  # 函数主体
}

	- t：实际的死亡日期向量，长度为150

	- deaths：每天的死亡人数，长度为150

	- n.rep：总体迭代次数，默认为100

	- bs：逻辑值，指示是否进行引导法，默认为FALSE

	- t0：初始的感染时间向量，默认为NULL。如果提供，则使用给定的t0进行初始化

	- 如果t0为NULL，按照步骤2生成初始的感染时间向量

- 返回一个列表，至少包含以下元素

	- P：长度为n.rep的向量，记录每次总体迭代后的P值

	- inft：大小为310 x n.rep的矩阵，每列是对应迭代后的每日新感染人数

	- t0：最终的感染时间向量

### 确保函数能够处理引导法（bootstrap）以量化不确定性

- 如果bs=TRUE，在每次总体迭代开始前，模拟新的死亡数据

  为什么要模拟新的死亡数据？目前的死亡数据是根据 感染时间 + 感染到死亡的时间 模拟的。
  
- 假设每日死亡人数服从Poisson分布，其均值为实际的死亡人数

- 使用rpois函数生成新的每日死亡人数

### 函数内部绘图（可选）

- 在每次总体迭代结束后，绘制当前的估计结果：

- 当前的每日新感染人数（感染率）

- 实际的每日死亡人数

- 模拟的每日死亡人数

## 5. 结果的可视化与分析

### 绘制估计的感染率曲线，包含不确定性范围

- 运行函数并获取结果

	- 使用适当的n.rep值运行deconv函数，直到结果收敛

	- 再次运行deconv函数，设置bs=TRUE，以进行引导法估计不确定性

	- 注意： 在第二次运行时，将第一次运行的t0作为初始值传递给函数，以加速收敛

- 绘制感染率曲线

	- 绘制估计的每日新感染人数曲线（致命感染率），使用 inft 矩阵的列平均值

	- 使用引导法的结果，计算每一天感染率的置信区间（例如，第2.5和97.5百分位数），并在图中显示不确定性范围

### 比较模拟的死亡数据与实际死亡数据

- 绘制实际的每日死亡人数和模拟的每日死亡人数，比较模型的拟合效果

- 可以在同一图中显示，也可以分别绘制

### 标注关键日期（如英国首次封锁日期）

- 在图中添加垂直线，标注英国首次封锁的日期（第84天，2020年3月24日）

- 使用abline(v=84, col="red", lty=2)添加垂直虚线

